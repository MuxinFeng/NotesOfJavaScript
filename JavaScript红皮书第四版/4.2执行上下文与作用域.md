### 4.2执行上下文与作用域
&emsp;每个执行上下文都对应一个变量对象，在这个上下文中声明的变量和函数都存在于这个对象上。上下文执行时，会形成一个作用域链，正在执行的上下文对应的变量对象处于作用域链的最前端，全局上下文对应的变量对象处于作用域链的最后。每个上下文都可以访问其父级及以上的上下文中的变量和函数，反之则不行。
*  在全局作用域，用var声明的变量和函数会成为window对象的属性和方法，const和let声明的不是，但效果一样；
* 当前上下文可以重复声明父级上下文的变量和函数，可以达到覆盖的效果；
#### 4.2.1作用域链增强
执行上下文主要分为全局上下文、函数上下文、***块级上下文***；
&emsp;作用域链增强可以理解为在作用域链最前端临时添加变量对象；
* with语句，会在作用域链最前端添加指定对象，该上下文中访问的变量和函数首先会从改指定对象寻找；
* try-catch语句，会在作用域链最前端添加对象，该对象包含要抛出的错误对象的声明；
#### 4.2.2变量声明
**var**
* var声明的变量和函数会被添加到最近的上下文，如果未经声明就初始化，该变量会默认为是全局上下文声明；
* var声明的变量和函数可进行变量提升，即无论在哪里声明（非初始化），该声明会被自动提升到该上下文其他代码的前面；
* 同一上下文，重复的声明会被忽略；
**let**
***为什么let比var更适合用做循环，而不会泄露***
* let重复声明会报错；
**const**
* const声明的时候要进行初始化，且不可被重新赋值或重新赋值其它引用，如果该变量是对象，可以修改对象内的值；
**标识符查找**
***低频知识点，暂不深入了解***
### 4.3垃圾回收
#### 4.3.1标记清理
&emsp;将所有上下文中都不会访问的变量做标记，在下次垃圾回收的时候会清理掉；
#### 4.3.2引用计数
&emsp;变量没被引用一次，引用值就加1，当引用值为0时，代表可以回收，这种方式不推荐，因为会出现循环引用，还可能因为***把变量设置为null会实际切断变量和引用值之间的联系***
#### 4.3.3性能
***低频知识点，暂不深入了解***
#### 4.3.2内存管理
***未充分学习，暂不总结***